package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/peer"

	pb "enrutador-gateway-go/proto"
)

// ConnectorGRPCServer handles gRPC connections from Data Connectors (reverse tunnel mode)
// Using native protobuf types generated by protoc
type ConnectorGRPCServer struct {
	pb.UnimplementedConnectorServiceServer
	registry    *ConnectorRegistry
	grpcServer  *grpc.Server
	port        int
	mtlsEnabled bool
	certsPath   string
}

// NewConnectorGRPCServer creates a new gRPC server for connector connections
func NewConnectorGRPCServer(registry *ConnectorRegistry, port int) *ConnectorGRPCServer {
	// Check if mTLS certs exist
	certsPath := "certs"
	mtlsEnabled := false
	if _, err := os.Stat(certsPath + "/ca.crt"); err == nil {
		if _, err := os.Stat(certsPath + "/server.crt"); err == nil {
			mtlsEnabled = true
		}
	}
	return &ConnectorGRPCServer{
		registry:    registry,
		port:        port,
		mtlsEnabled: mtlsEnabled,
		certsPath:   certsPath,
	}
}

// Start starts the gRPC server
func (s *ConnectorGRPCServer) Start() error {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", s.port))
	if err != nil {
		return fmt.Errorf("failed to listen: %w", err)
	}

	// Allow larger messages for data transfer (100MB)
	maxMsgSize := 100 * 1024 * 1024 // 100 MB

	// Build server options
	opts := []grpc.ServerOption{
		grpc.MaxRecvMsgSize(maxMsgSize),
		grpc.MaxSendMsgSize(maxMsgSize),
	}

	// Add mTLS if enabled
	if s.mtlsEnabled {
		tlsConfig, err := s.loadTLSConfig()
		if err != nil {
			return fmt.Errorf("failed to load TLS config: %w", err)
		}
		opts = append(opts, grpc.Creds(credentials.NewTLS(tlsConfig)))
		log.Printf("[ConnectorGRPC] mTLS ENABLED - requiring client certificates")
	} else {
		log.Printf("[ConnectorGRPC] mTLS DISABLED - using insecure connection")
	}

	s.grpcServer = grpc.NewServer(opts...)
	pb.RegisterConnectorServiceServer(s.grpcServer, s)

	log.Printf("[ConnectorGRPC] Starting gRPC server on :%d (native protobuf, max msg: %dMB)", s.port, maxMsgSize/(1024*1024))
	return s.grpcServer.Serve(lis)
}

// loadTLSConfig loads mTLS configuration
func (s *ConnectorGRPCServer) loadTLSConfig() (*tls.Config, error) {
	// Load server certificate
	cert, err := tls.LoadX509KeyPair(
		s.certsPath+"/server.crt",
		s.certsPath+"/server.key",
	)
	if err != nil {
		return nil, fmt.Errorf("load server cert: %w", err)
	}

	// Load CA to verify client certificates
	caCert, err := os.ReadFile(s.certsPath + "/ca.crt")
	if err != nil {
		return nil, fmt.Errorf("load CA cert: %w", err)
	}
	caPool := x509.NewCertPool()
	if !caPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to parse CA certificate")
	}

	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientCAs:    caPool,
		ClientAuth:   tls.RequireAndVerifyClientCert, // mTLS!
	}, nil
}

// Stop stops the gRPC server gracefully
func (s *ConnectorGRPCServer) Stop() {
	if s.grpcServer != nil {
		s.grpcServer.GracefulStop()
	}
}

// Connect handles the bidirectional stream using native protobuf types
func (s *ConnectorGRPCServer) Connect(stream pb.ConnectorService_ConnectServer) error {
	// Extract tenant_id from client certificate if mTLS is enabled
	var certTenantID string
	if s.mtlsEnabled {
		p, ok := peer.FromContext(stream.Context())
		if ok && p.AuthInfo != nil {
			if tlsInfo, ok := p.AuthInfo.(credentials.TLSInfo); ok {
				if len(tlsInfo.State.VerifiedChains) > 0 && len(tlsInfo.State.VerifiedChains[0]) > 0 {
					clientCert := tlsInfo.State.VerifiedChains[0][0]
					certTenantID = clientCert.Subject.CommonName
					log.Printf("[ConnectorGRPC] Client certificate CN: %s", certTenantID)
				}
			}
		}
		if certTenantID == "" {
			log.Printf("[ConnectorGRPC] No valid client certificate found")
			return fmt.Errorf("mTLS required but no valid client certificate")
		}
	}

	// Wait for registration message
	msg, err := stream.Recv()
	if err != nil {
		log.Printf("[ConnectorGRPC] Recv error: %v", err)
		return err
	}

	register := msg.GetRegister()
	if register == nil {
		log.Printf("[ConnectorGRPC] Invalid registration: no register payload")
		stream.Send(&pb.GatewayCommand{
			RequestId: msg.RequestId,
			Command: &pb.GatewayCommand_RegisterResponse{
				RegisterResponse: &pb.RegisterResponse{
					Status: "error",
					Error:  "invalid registration",
				},
			},
		})
		return fmt.Errorf("invalid registration")
	}

	tenantID := register.TenantId
	if tenantID == "" {
		return fmt.Errorf("empty tenant_id")
	}

	// Validate tenant_id matches certificate CN if mTLS is enabled
	if s.mtlsEnabled && certTenantID != tenantID {
		log.Printf("[ConnectorGRPC] Certificate CN mismatch: cert=%s, register=%s", certTenantID, tenantID)
		stream.Send(&pb.GatewayCommand{
			RequestId: msg.RequestId,
			Command: &pb.GatewayCommand_RegisterResponse{
				RegisterResponse: &pb.RegisterResponse{
					Status: "error",
					Error:  fmt.Sprintf("tenant_id mismatch: certificate CN is '%s' but tried to register as '%s'", certTenantID, tenantID),
				},
			},
		})
		return fmt.Errorf("tenant_id mismatch")
	}

	sessionID := base64.RawURLEncoding.EncodeToString([]byte(time.Now().Format("20060102150405")))

	// Create client wrapper
	client := NewNativeGRPCClient(stream, tenantID, sessionID)

	// Register with registry
	s.registry.RegisterGRPCConnector(tenantID, client)
	defer s.registry.UnregisterGRPCConnector(tenantID)

	// Send confirmation
	stream.Send(&pb.GatewayCommand{
		RequestId: msg.RequestId,
		Command: &pb.GatewayCommand_RegisterResponse{
			RegisterResponse: &pb.RegisterResponse{
				Status:    "ok",
				SessionId: sessionID,
			},
		},
	})

	log.Printf("[ConnectorGRPC] Registered: tenant=%s session=%s version=%s", tenantID, sessionID, register.Version)

	// Start heartbeat goroutine
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go s.keepalive(ctx, stream, tenantID)

	// Main message loop - receive messages from connector
	for {
		msg, err := stream.Recv()
		if err == io.EOF {
			log.Printf("[ConnectorGRPC] Stream closed: tenant=%s", tenantID)
			return nil
		}
		if err != nil {
			log.Printf("[ConnectorGRPC] Recv error: tenant=%s err=%v", tenantID, err)
			return err
		}

		client.handleMessage(msg)
	}
}

// keepalive sends periodic heartbeats
func (s *ConnectorGRPCServer) keepalive(ctx context.Context, stream pb.ConnectorService_ConnectServer, tenantID string) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			err := stream.Send(&pb.GatewayCommand{
				RequestId: fmt.Sprintf("hb_%d", time.Now().UnixNano()),
				Command: &pb.GatewayCommand_Heartbeat{
					Heartbeat: &pb.Heartbeat{
						Timestamp: time.Now().Unix(),
					},
				},
			})
			if err != nil {
				log.Printf("[ConnectorGRPC] Heartbeat failed for %s: %v", tenantID, err)
				return
			}
		}
	}
}

// ============== Native gRPC Client Wrapper ==============

// NativeGRPCClient wraps a gRPC stream to act as a connector client using native protobuf
type NativeGRPCClient struct {
	stream    pb.ConnectorService_ConnectServer
	tenantID  string
	sessionID string
	pending   map[string]chan *pb.ConnectorMessage
	pendingMu sync.RWMutex
	chunks    map[string]chan []byte
	chunksMu  sync.RWMutex
	writeMu   sync.Mutex
}

// NewNativeGRPCClient creates a new native gRPC-based connector client
func NewNativeGRPCClient(stream pb.ConnectorService_ConnectServer, tenantID, sessionID string) *NativeGRPCClient {
	return &NativeGRPCClient{
		stream:    stream,
		tenantID:  tenantID,
		sessionID: sessionID,
		pending:   make(map[string]chan *pb.ConnectorMessage),
		chunks:    make(map[string]chan []byte),
	}
}

// handleMessage routes messages from the connector
func (c *NativeGRPCClient) handleMessage(msg *pb.ConnectorMessage) {
	requestID := msg.RequestId

	// Handle FlightInfo response
	if info := msg.GetFlightInfo(); info != nil {
		c.pendingMu.RLock()
		ch, exists := c.pending[requestID]
		c.pendingMu.RUnlock()

		if exists {
			select {
			case ch <- msg:
			default:
			}
		}
		return
	}

	// Handle Arrow chunk (binary data directly, no base64!)
	if chunk := msg.GetArrowChunk(); chunk != nil {
		c.chunksMu.RLock()
		ch, exists := c.chunks[requestID]
		c.chunksMu.RUnlock()

		if exists {
			select {
			case ch <- chunk.Data: // Direct bytes, no decoding needed!
			default:
				log.Printf("[ConnectorGRPC] Channel full for request %s", requestID)
			}
		}
		return
	}

	// Handle StreamStatus
	if status := msg.GetStreamStatus(); status != nil {
		if status.Type == "stream_end" {
			c.chunksMu.Lock()
			if ch, exists := c.chunks[requestID]; exists {
				close(ch)
				delete(c.chunks, requestID)
			}
			c.chunksMu.Unlock()
		}

		// Also route to pending
		c.pendingMu.RLock()
		ch, exists := c.pending[requestID]
		c.pendingMu.RUnlock()

		if exists {
			select {
			case ch <- msg:
			default:
			}
		}
		return
	}

	// Handle heartbeat response (ignore)
	if msg.GetHeartbeat() != nil {
		return
	}
}

// SendGetFlightInfo sends a GetFlightInfo command and waits for response
func (c *NativeGRPCClient) SendGetFlightInfo(ctx context.Context, requestID string, path []string) (*pb.FlightInfoResponse, error) {
	respCh := make(chan *pb.ConnectorMessage, 1)
	c.pendingMu.Lock()
	c.pending[requestID] = respCh
	c.pendingMu.Unlock()

	defer func() {
		c.pendingMu.Lock()
		delete(c.pending, requestID)
		c.pendingMu.Unlock()
	}()

	c.writeMu.Lock()
	err := c.stream.Send(&pb.GatewayCommand{
		RequestId: requestID,
		Command: &pb.GatewayCommand_GetFlightInfo{
			GetFlightInfo: &pb.GetFlightInfoRequest{
				Path: path,
			},
		},
	})
	c.writeMu.Unlock()

	if err != nil {
		return nil, err
	}

	select {
	case resp := <-respCh:
		return resp.GetFlightInfo(), nil
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// SendDoGet sends a DoGet command and returns a channel for receiving chunks
func (c *NativeGRPCClient) SendDoGet(ctx context.Context, requestID, ticket string) (chan []byte, error) {
	chunkCh := make(chan []byte, 1000)
	c.chunksMu.Lock()
	c.chunks[requestID] = chunkCh
	c.chunksMu.Unlock()

	c.writeMu.Lock()
	err := c.stream.Send(&pb.GatewayCommand{
		RequestId: requestID,
		Command: &pb.GatewayCommand_DoGet{
			DoGet: &pb.DoGetRequest{
				Ticket: ticket,
			},
		},
	})
	c.writeMu.Unlock()

	if err != nil {
		c.chunksMu.Lock()
		delete(c.chunks, requestID)
		c.chunksMu.Unlock()
		return nil, err
	}

	return chunkCh, nil
}

// ============== Update ConnectorRegistry to use NativeGRPCClient ==============

// GetNativeGRPCClient returns the native gRPC client for a tenant
func (r *ConnectorRegistry) GetNativeGRPCClient(tenantID string) (*NativeGRPCClient, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	client, exists := r.grpcClients[tenantID]
	if !exists {
		return nil, false
	}
	// Type assert to NativeGRPCClient
	nativeClient, ok := client.(*NativeGRPCClient)
	return nativeClient, ok
}

// queryDataViaGRPCBidiNative handles data queries via gRPC bidirectional tunnel with native protobuf
func (r *ConnectorRegistry) queryDataViaGRPCBidiNative(ctx context.Context, tenantID, dataset string, chunks chan []byte) error {
	client, exists := r.GetNativeGRPCClient(tenantID)
	if !exists {
		return fmt.Errorf("native gRPC client not found for tenant: %s", tenantID)
	}

	// Timeout
	ctx, cancel := context.WithTimeout(ctx, 120*time.Second)
	defer cancel()

	requestID := fmt.Sprintf("query_%d", time.Now().UnixNano())

	// 1. Send GetFlightInfo
	log.Printf("[ConnectorRegistry] Native gRPC GetFlightInfo for %s", dataset)
	infoResp, err := client.SendGetFlightInfo(ctx, requestID, []string{dataset})
	if err != nil {
		return fmt.Errorf("get_flight_info failed: %w", err)
	}

	if infoResp == nil || infoResp.Status != "ok" {
		errMsg := ""
		if infoResp != nil {
			errMsg = infoResp.Error
		}
		return fmt.Errorf("get_flight_info error: %s", errMsg)
	}

	partitions := int(infoResp.Partitions)
	if partitions < 1 {
		partitions = 1
	}

	log.Printf("[ConnectorRegistry] Native gRPC GetFlightInfo: %d partitions, %d records", partitions, infoResp.TotalRecords)

	// 2. Send DoGet command
	doGetID := fmt.Sprintf("doget_%d", time.Now().UnixNano())
	log.Printf("[ConnectorRegistry] Native gRPC DoGet for %s", dataset)

	ticketData := map[string]interface{}{
		"dataset":          dataset,
		"partition":        0,
		"total_partitions": partitions,
	}
	ticketBytes, _ := json.Marshal(ticketData)
	ticketB64 := base64.StdEncoding.EncodeToString(ticketBytes)

	chunkCh, err := client.SendDoGet(ctx, doGetID, ticketB64)
	if err != nil {
		return fmt.Errorf("doget send failed: %w", err)
	}

	// 3. Receive chunks until channel is closed
	for {
		select {
		case chunk, ok := <-chunkCh:
			if !ok {
				log.Printf("[ConnectorRegistry] Native gRPC DoGet complete")
				return nil
			}
			select {
			case chunks <- chunk:
			case <-ctx.Done():
				return ctx.Err()
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}
