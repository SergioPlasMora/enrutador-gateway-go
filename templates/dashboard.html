<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arrow Dashboard + DuckDB WASM</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script type="module">
      import { tableFromIPC } from 'https://cdn.jsdelivr.net/npm/apache-arrow@14.0.2/+esm';
      import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm';
      window.Arrow = { tableFromIPC };
      window.DuckDB = duckdb;
    </script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
        color: #e7e9ea;
        min-height: 100vh;
        padding: 1.5rem;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #2f3336;
      }
      .header h1 {
        font-size: 1.5rem;
        background: linear-gradient(90deg, #1d9bf0, #00ba7c);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      .header .controls {
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      input,
      select {
        background: #202e3a;
        border: 1px solid #2f3336;
        border-radius: 8px;
        padding: 0.5rem 0.75rem;
        color: #e7e9ea;
        font-size: 13px;
      }
      input:focus,
      select:focus {
        outline: none;
        border-color: #1d9bf0;
      }

      button {
        background: linear-gradient(90deg, #1d9bf0, #0d8de0);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 13px;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(29, 155, 240, 0.4);
      }
      button:disabled {
        background: #38444d;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      button.secondary {
        background: #202e3a;
        border: 1px solid #2f3336;
      }

      .status-bar {
        display: flex;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }
      .status-item {
        background: #16202a;
        border: 1px solid #2f3336;
        border-radius: 10px;
        padding: 1rem 1.5rem;
        flex: 1;
        min-width: 150px;
      }
      .status-item .label {
        font-size: 11px;
        color: #71767b;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .status-item .value {
        font-size: 1.5rem;
        font-weight: bold;
        margin-top: 0.25rem;
      }
      .status-item .value.blue {
        color: #1d9bf0;
      }
      .status-item .value.green {
        color: #00ba7c;
      }
      .status-item .value.orange {
        color: #f7931a;
      }
      .status-item .value.purple {
        color: #7856ff;
      }

      .connection-status {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: #16202a;
        border-radius: 20px;
        font-size: 12px;
      }
      .connection-status .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #71767b;
      }
      .connection-status.connected .dot {
        background: #00ba7c;
      }
      .connection-status.error .dot {
        background: #f44;
      }

      .dashboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 1.5rem;
      }

      .chart-card {
        background: #16202a;
        border: 1px solid #2f3336;
        border-radius: 12px;
        padding: 1.25rem;
      }
      .chart-card h3 {
        font-size: 0.9rem;
        color: #71767b;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .chart-card h3::before {
        content: "";
        width: 8px;
        height: 8px;
        background: #1d9bf0;
        border-radius: 50%;
      }
      .chart-container {
        position: relative;
        height: 250px;
      }

      .chart-card.wide {
        grid-column: span 2;
      }

      .data-table {
        background: #16202a;
        border: 1px solid #2f3336;
        border-radius: 12px;
        padding: 1.25rem;
        grid-column: span 2;
        max-height: 400px;
        overflow: auto;
      }
      .data-table h3 {
        font-size: 0.9rem;
        color: #71767b;
        margin-bottom: 1rem;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      th {
        text-align: left;
        padding: 0.75rem;
        border-bottom: 1px solid #2f3336;
        color: #71767b;
        font-weight: 500;
        position: sticky;
        top: 0;
        background: #16202a;
      }
      td {
        padding: 0.75rem;
        border-bottom: 1px solid #202e3a;
      }
      tr:hover {
        background: #1a2836;
      }

      .progress-bar {
        position: fixed;
        top: 0;
        left: 0;
        height: 3px;
        background: linear-gradient(90deg, #1d9bf0, #00ba7c);
        width: 0%;
        transition: width 0.3s;
        z-index: 1000;
      }

      #log {
        position: fixed;
        bottom: 20rem;
        right: 1rem;
        width: 350px;
        max-height: 200px;
        background: #16202a;
        border: 1px solid #2f3336;
        border-radius: 8px;
        padding: 0.75rem;
        font-size: 11px;
        font-family: monospace;
        overflow-y: auto;
        z-index: 100;
        opacity: 0.9;
      }
      #log:hover {
        opacity: 1;
      }
      .log-entry {
        margin: 0.2rem 0;
      }
      .log-time {
        color: #71767b;
      }
      .log-info {
        color: #1d9bf0;
      }
      .log-success {
        color: #00ba7c;
      }
      .log-error {
        color: #f44;
      }

      @media (max-width: 900px) {
        .dashboard {
          grid-template-columns: 1fr;
        }
        .chart-card.wide,
        .data-table {
          grid-column: span 1;
        }
        #log {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="progress-bar" id="progress-bar"></div>

    <div class="header">
      <h1>ü¶Ü Arrow + DuckDB Dashboard</h1>
      <div class="controls">
        <div class="connection-status" id="ws-status">
          <span class="dot"></span>
          <span id="ws-status-text">Disconnected</span>
        </div>
        <input
          id="session-id"
          value=""
          placeholder="Session ID (del Connector)"
          style="width: 200px"
        />
        <button onclick="reconnect()" class="secondary">üîÑ Connect</button>
        <select id="dataset" style="width: 180px">
          <option value="dataset_1kb">dataset_1kb.json (1 KB)</option>
          <option value="dataset_1mb.csv">dataset_1mb.csv (1 MB)</option>
          <option value="dataset_1mb.parquet">dataset_1mb.parquet (1 MB)</option>
          <option value="dataset_10mb.csv" selected>dataset_10mb.csv (10 MB)</option>
          <option value="dataset_10mb.parquet">dataset_10mb.parquet (10 MB)</option>
          <option value="dataset_20mb.csv">dataset_20mb.csv (20 MB)</option>
          <option value="dataset_20mb.parquet">dataset_20mb.parquet (20 MB)</option>
          <option value="dataset_30mb.csv">dataset_30mb.csv (30 MB)</option>
          <option value="dataset_30mb.parquet">dataset_30mb.parquet (30 MB)</option>
          <option value="dataset_40mb.csv">dataset_40mb.csv (40 MB)</option>
          <option value="dataset_40mb.parquet">dataset_40mb.parquet (40 MB)</option>
          <option value="dataset_50mb.csv">dataset_50mb.csv (50 MB)</option>
          <option value="dataset_50mb.parquet">dataset_50mb.parquet (50 MB)</option>
          <option value="dataset_100mb.csv">dataset_100mb.csv (100 MB)</option>
          <option value="dataset_100mb.parquet">dataset_100mb.parquet (100 MB)</option>
          <option value="dataset_100mb.duckdb">dataset_100mb.duckdb (100 MB)</option>
          <option value="dataset_500mb.duckdb">dataset_500mb.duckdb (500 MB)</option>
        </select>
        <button onclick="loadData()" id="load-btn">üöÄ Load Data</button>
        <button onclick="clearData()" class="secondary">üóëÔ∏è Clear</button>
      </div>
    </div>

    <div class="status-bar">
      <div class="status-item">
        <div class="label">Records</div>
        <div class="value blue" id="total-records">0</div>
      </div>
      <div class="status-item">
        <div class="label">Total Value</div>
        <div class="value green" id="total-value">$0</div>
      </div>
      <div class="status-item">
        <div class="label">Average</div>
        <div class="value orange" id="avg-value">$0</div>
      </div>
      <div class="status-item">
        <div class="label">Categories</div>
        <div class="value purple" id="categories">0</div>
      </div>
      <div class="status-item">
        <div class="label">Transfer Time</div>
        <div class="value" id="load-time">0.00s</div>
      </div>
    </div>

    <div class="dashboard">
      <div class="chart-card">
        <h3>Distribution by Category</h3>
        <div class="chart-container">
          <canvas id="categoryChart"></canvas>
        </div>
      </div>

      <div class="chart-card">
        <h3>Total Value by Category</h3>
        <div class="chart-container">
          <canvas id="valueChart"></canvas>
        </div>
      </div>

      <div class="chart-card wide">
        <h3>Value Distribution Histogram</h3>
        <div class="chart-container">
          <canvas id="histogramChart"></canvas>
        </div>
      </div>

      <div class="data-table">
        <h3>Sample Data <span id="table-count">(0)</span></h3>
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Value</th>
              <th>Category</th>
              <th>Timestamp</th>
            </tr>
          </thead>
          <tbody id="data-table-body">
            <tr>
              <td colspan="5" style="text-align: center; color: #71767b">
                Load data to see records
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- DuckDB Query Panel -->
      <div class="chart-card wide" id="duckdb-panel">
        <h3>ü¶Ü DuckDB WASM - SQL Query</h3>
        <div id="duckdb-status" style="margin-bottom: 1rem; color: #f7931a;">Initializing DuckDB...</div>
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <textarea id="sql-input" style="flex: 1; background: #202e3a; border: 1px solid #2f3336; border-radius: 8px; padding: 0.75rem; color: #e7e9ea; font-family: monospace; font-size: 13px; resize: vertical; min-height: 60px;">SELECT category, COUNT(*) as total, AVG(value) as avg_value FROM data GROUP BY category</textarea>
          <button onclick="runSQLQuery()" id="sql-btn" disabled style="align-self: flex-start;">‚ñ∂ Run</button>
        </div>
        <div id="sql-results" style="max-height: 300px; overflow: auto;"></div>
        <div style="margin-top: 0.5rem; font-size: 11px; color: #71767b;">Tip: Tambi√©n puedes usar <code>await query("SQL")</code> en la consola (F12)</div>
      </div>
    </div>

    <div id="log"></div>

    <script>
      // Estado global
      let ws = null;
      let allData = [];
      let charts = {};
      let chunks = [];
      let startTime = 0;
      
      // DuckDB WASM
      let duckDB = null;
      let duckConn = null;
      let duckDBReady = false;

      // Colores del tema
      const colors = {
        A: { bg: "rgba(29, 155, 240, 0.7)", border: "#1d9bf0" },
        B: { bg: "rgba(0, 186, 124, 0.7)", border: "#00ba7c" },
        C: { bg: "rgba(247, 147, 26, 0.7)", border: "#f7931a" },
      };

      const chartDefaults = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { labels: { color: "#71767b", font: { size: 11 } } },
        },
        scales: {
          x: {
            ticks: { color: "#71767b", font: { size: 10 } },
            grid: { color: "#2f3336" },
          },
          y: {
            ticks: { color: "#71767b", font: { size: 10 } },
            grid: { color: "#2f3336" },
          },
        },
      };

      function log(msg, type = "info") {
        const el = document.getElementById("log");
        const time = new Date().toISOString().slice(11, 19);
        el.innerHTML =
          `<div class="log-entry"><span class="log-time">[${time}]</span> <span class="log-${type}">${msg}</span></div>` +
          el.innerHTML;
        if (el.children.length > 50) el.lastChild.remove();
      }

      function updateConnectionStatus(status) {
        const el = document.getElementById("ws-status");
        const text = document.getElementById("ws-status-text");
        el.className = "connection-status " + status;
        text.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }

      function formatNumber(num) {
        return new Intl.NumberFormat("en-US").format(num);
      }

      function formatCurrency(num) {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: "USD",
        }).format(num);
      }

      // Conectar WebSocket
      function connectWebSocket() {
        const sessionId = document.getElementById('session-id').value.trim();
        if (!sessionId) {
          log('Enter a Session ID to connect', 'error');
          updateConnectionStatus('disconnected');
          return;
        }
        
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/stream/${sessionId}`;

        log(`Connecting to ${wsUrl}...`);
        ws = new WebSocket(wsUrl);
        ws.binaryType = "arraybuffer";

        ws.onopen = () => {
          updateConnectionStatus("connected");
          log("WebSocket connected", "success");
        };

        ws.onclose = () => {
          updateConnectionStatus("disconnected");
          log("WebSocket disconnected");
          // Don't auto-reconnect - wait for user to click Connect
        };

        ws.onerror = (e) => {
          updateConnectionStatus("error");
          log("WebSocket error", "error");
        };

        ws.onmessage = handleMessage;
      }

      // Manejar mensajes del servidor
      async function handleMessage(event) {
        if (event.data instanceof ArrayBuffer) {
          // Chunk binario Arrow IPC
          chunks.push(new Uint8Array(event.data));
          const totalBytes = chunks.reduce((sum, c) => sum + c.length, 0);
          document.getElementById("progress-bar").style.width =
            Math.min((totalBytes / 1000000) * 10, 100) + "%";
          log(`Received chunk: ${(totalBytes / 1024).toFixed(0)} KB`);
        } else {
          // Mensaje JSON de control
          const msg = JSON.parse(event.data);
          log(`Control: ${msg.status}`);

          if (msg.status === "complete") {
            await processArrowData();
          } else if (msg.status === "error") {
            log(`Error: ${msg.error}`, "error");
            document.getElementById("load-btn").disabled = false;
          }
        }
      }

      // Procesar datos Arrow
      async function processArrowData() {
        const loadTime = (performance.now() - startTime) / 1000;
        document.getElementById("load-time").textContent =
          loadTime.toFixed(2) + "s";

        try {
          // Combinar chunks
          const totalLength = chunks.reduce((sum, c) => sum + c.length, 0);
          const combined = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
          }

          log(`Processing ${(totalLength / 1024 / 1024).toFixed(2)} MB...`);

          // Parsear Arrow IPC
          const table = Arrow.tableFromIPC(combined);

          // Convertir a array de objetos
          allData = [];
          const numRows = table.numRows;

          // Obtener columnas
          const columns = {};
          for (const field of table.schema.fields) {
            columns[field.name] = table.getChild(field.name);
          }

          // Extraer datos (sample si hay muchos)
          const sampleSize = Math.min(numRows, 100000);
          const step = Math.max(1, Math.floor(numRows / sampleSize));

          for (let i = 0; i < numRows; i += step) {
            const row = {};
            for (const [name, col] of Object.entries(columns)) {
              row[name] = col.get(i);
            }
            allData.push(row);
          }

          log(
            `‚úì Parsed ${formatNumber(numRows)} rows in ${loadTime.toFixed(2)}s`,
            "success"
          );
          
          // === DUCKDB WASM: Cargar Arrow IPC directamente ===
          if (duckDBReady && combined.byteLength > 0) {
            try {
              const duckStart = performance.now();
              
              // Drop existing table
              await duckConn.query(`DROP TABLE IF EXISTS data`);
              
              // Method 1: Try to insert Arrow from IPC Stream directly
              // DuckDB WASM has insertArrowFromIPCStream on the connection
              if (typeof duckConn.insertArrowFromIPCStream === 'function') {
                await duckConn.insertArrowFromIPCStream(combined, { name: 'data' });
                
                const countResult = await duckConn.query(`SELECT COUNT(*) as cnt FROM data`);
                const rowCount = Number(countResult.toArray()[0].cnt);
                
                const duckTime = Math.round(performance.now() - duckStart);
                log(`ü¶Ü DuckDB: ${formatNumber(rowCount)} rows loaded via Arrow IPC in ${duckTime}ms`, 'success');
                document.getElementById('duckdb-status').textContent = `‚úÖ Tabla 'data' lista: ${formatNumber(rowCount)} filas`;
                document.getElementById('duckdb-status').style.color = '#00ba7c';
                document.getElementById('sql-btn').disabled = false;
              } else {
                // If insertArrowFromIPCStream doesn't exist, throw to trigger fallback
                throw new Error('insertArrowFromIPCStream not available, using fallback');
              }
            } catch (duckErr) {
              // Fallback: Try inserting from the parsed allData if Arrow IPC fails
              log(`ü¶Ü Arrow IPC failed, trying JSON fallback...`, 'info');
              try {
                await duckConn.query(`DROP TABLE IF EXISTS data`);
                
                // Limit to prevent memory issues - sample if too large
                const maxRows = 50000;
                const dataToLoad = allData.length > maxRows 
                  ? allData.filter((_, i) => i % Math.ceil(allData.length / maxRows) === 0)
                  : allData;
                
                const cols = Object.keys(dataToLoad[0]);
                
                // Infer types from data - be conservative
                const colTypes = cols.map(c => {
                  const sample = dataToLoad.slice(0, 100).map(r => r[c]).filter(v => v != null);
                  if (sample.every(v => typeof v === 'number' && Number.isFinite(v))) return 'DOUBLE';
                  if (sample.every(v => typeof v === 'bigint')) return 'BIGINT';
                  return 'VARCHAR';
                });
                
                const colDefs = cols.map((c, i) => `"${c}" ${colTypes[i]}`).join(', ');
                await duckConn.query(`CREATE TABLE data (${colDefs})`);
                
                // Insert in smaller batches to avoid memory issues
                const batchSize = 500;
                for (let i = 0; i < dataToLoad.length; i += batchSize) {
                  const batch = dataToLoad.slice(i, i + batchSize);
                  const values = batch.map(row => 
                    '(' + cols.map((c, idx) => {
                      const v = row[c];
                      if (v === null || v === undefined) return 'NULL';
                      if (colTypes[idx] === 'DOUBLE' || colTypes[idx] === 'BIGINT') {
                        return typeof v === 'bigint' ? String(v) : String(Number(v) || 0);
                      }
                      return `'${String(v).replace(/'/g, "''").substring(0, 1000)}'`;
                    }).join(', ') + ')'
                  ).join(', ');
                  await duckConn.query(`INSERT INTO data VALUES ${values}`);
                  
                  // Progress update
                  if (i % 5000 === 0 && i > 0) {
                    log(`ü¶Ü Loading... ${Math.round(i/dataToLoad.length*100)}%`);
                  }
                }
                
                const duckTime = Math.round(performance.now() - duckStart);
                log(`ü¶Ü DuckDB: ${formatNumber(dataToLoad.length)} rows loaded in ${duckTime}ms (fallback)`, 'success');
                document.getElementById('duckdb-status').textContent = `‚úÖ Tabla 'data' lista: ${formatNumber(dataToLoad.length)} filas`;
                document.getElementById('duckdb-status').style.color = '#00ba7c';
                document.getElementById('sql-btn').disabled = false;
              } catch (fallbackErr) {
                log(`ü¶Ü DuckDB error: ${fallbackErr.message}`, 'error');
                console.error('DuckDB fallback error:', fallbackErr);
                document.getElementById('duckdb-status').textContent = '‚ö†Ô∏è Error cargando datos - intenta con dataset m√°s peque√±o';
                document.getElementById('duckdb-status').style.color = '#f7931a';
              }
            }
          }

          // Renderizar dashboard
          updateDashboard();
        } catch (e) {
          log(`Parse error: ${e.message}`, "error");
          console.error(e);
        } finally {
          document.getElementById("load-btn").disabled = false;
          document.getElementById("progress-bar").style.width = "100%";
          setTimeout(
            () => (document.getElementById("progress-bar").style.width = "0%"),
            1000
          );
        }
      }

      // Cargar datos
      function loadData() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("WebSocket not connected - click Connect first", "error");
          return;
        }

        const dataset = document.getElementById("dataset").value;

        document.getElementById("load-btn").disabled = true;
        chunks = [];
        startTime = performance.now();

        log(`Requesting: ${dataset}`);

        ws.send(
          JSON.stringify({
            action: "query",
            dataset: dataset,
          })
        );
      }
      
      // Reconnect WebSocket
      function reconnect() {
        if (ws) {
          ws.close();
        }
        connectWebSocket();
      }

      function updateDashboard() {
        if (allData.length === 0) return;

        // Detectar nombres de columnas
        const firstRow = allData[0];
        const valueCol =
          "value" in firstRow
            ? "value"
            : Object.keys(firstRow).find(
                (k) => typeof firstRow[k] === "number"
              );
        const catCol =
          "category" in firstRow
            ? "category"
            : Object.keys(firstRow).find(
                (k) =>
                  typeof firstRow[k] === "string" && firstRow[k].length < 10
              );

        // Stats
        const values = allData.map((r) => r[valueCol] || 0);
        const totalValue = values.reduce((sum, v) => sum + v, 0);
        const avgValue = totalValue / allData.length;
        const categories = [...new Set(allData.map((r) => r[catCol]))].filter(
          Boolean
        );

        document.getElementById("total-records").textContent = formatNumber(
          allData.length
        );
        document.getElementById("total-value").textContent =
          formatCurrency(totalValue);
        document.getElementById("avg-value").textContent =
          formatCurrency(avgValue);
        document.getElementById("categories").textContent = categories.length;

        // Charts
        updateCategoryChart(catCol);
        updateValueChart(catCol, valueCol);
        updateHistogramChart(valueCol);
        updateTable();
      }

      function updateCategoryChart(catCol) {
        const ctx = document.getElementById("categoryChart");
        const counts = {};
        allData.forEach((r) => {
          const cat = r[catCol] || "Unknown";
          counts[cat] = (counts[cat] || 0) + 1;
        });

        if (charts.category) charts.category.destroy();

        charts.category = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: Object.keys(counts),
            datasets: [
              {
                data: Object.values(counts),
                backgroundColor: Object.keys(counts).map(
                  (c, i) => colors[c]?.bg || `hsla(${i * 60}, 70%, 50%, 0.7)`
                ),
                borderColor: Object.keys(counts).map(
                  (c, i) => colors[c]?.border || `hsl(${i * 60}, 70%, 50%)`
                ),
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: "right",
                labels: { color: "#71767b", font: { size: 12 }, padding: 15 },
              },
            },
          },
        });
      }

      function updateValueChart(catCol, valueCol) {
        const ctx = document.getElementById("valueChart");
        const totals = {};
        allData.forEach((r) => {
          const cat = r[catCol] || "Unknown";
          totals[cat] = (totals[cat] || 0) + (r[valueCol] || 0);
        });

        if (charts.value) charts.value.destroy();

        charts.value = new Chart(ctx, {
          type: "bar",
          data: {
            labels: Object.keys(totals),
            datasets: [
              {
                label: "Total Value",
                data: Object.values(totals),
                backgroundColor: Object.keys(totals).map(
                  (c, i) => colors[c]?.bg || `hsla(${i * 60}, 70%, 50%, 0.7)`
                ),
                borderColor: Object.keys(totals).map(
                  (c, i) => colors[c]?.border || `hsl(${i * 60}, 70%, 50%)`
                ),
                borderWidth: 2,
                borderRadius: 6,
              },
            ],
          },
          options: {
            ...chartDefaults,
            plugins: { legend: { display: false } },
          },
        });
      }

      function updateHistogramChart(valueCol) {
        const ctx = document.getElementById("histogramChart");
        const values = allData
          .map((r) => r[valueCol] || 0)
          .filter((v) => !isNaN(v));

        const min = Math.min(...values);
        const max = Math.max(...values);
        const bucketCount = 20;
        const bucketSize = (max - min) / bucketCount || 1;

        const buckets = new Array(bucketCount).fill(0);
        values.forEach((v) => {
          const idx = Math.min(
            Math.floor((v - min) / bucketSize),
            bucketCount - 1
          );
          buckets[idx]++;
        });

        const labels = buckets.map(
          (_, i) => `${(min + i * bucketSize).toFixed(0)}`
        );

        if (charts.histogram) charts.histogram.destroy();

        charts.histogram = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Count",
                data: buckets,
                backgroundColor: "rgba(120, 86, 255, 0.7)",
                borderColor: "#7856ff",
                borderWidth: 1,
                borderRadius: 2,
              },
            ],
          },
          options: {
            ...chartDefaults,
            plugins: { legend: { display: false } },
          },
        });
      }

      function updateTable() {
        const tbody = document.getElementById("data-table-body");
        const sample = allData.slice(0, 100);

        document.getElementById("table-count").textContent = `(showing ${
          sample.length
        } of ${formatNumber(allData.length)})`;

        const columns = Object.keys(sample[0] || {}).slice(0, 5);

        tbody.innerHTML = sample
          .map(
            (r) => `
                <tr>
                    ${columns
                      .map((col) => `<td>${formatCell(r[col])}</td>`)
                      .join("")}
                </tr>
            `
          )
          .join("");
      }

      function formatCell(value) {
        if (value === null || value === undefined) return "-";
        if (typeof value === "number") return value.toLocaleString();
        if (typeof value === "bigint") return value.toString();
        return String(value);
      }

      function clearData() {
        allData = [];
        chunks = [];
        Object.values(charts).forEach((c) => c?.destroy());
        charts = {};

        document.getElementById("total-records").textContent = "0";
        document.getElementById("total-value").textContent = "$0";
        document.getElementById("avg-value").textContent = "$0";
        document.getElementById("categories").textContent = "0";
        document.getElementById("load-time").textContent = "0.00s";
        document.getElementById("table-count").textContent = "(0)";
        document.getElementById("data-table-body").innerHTML =
          '<tr><td colspan="5" style="text-align: center; color: #71767b;">Load data to see records</td></tr>';

        ["categoryChart", "valueChart", "histogramChart"].forEach((id) => {
          const canvas = document.getElementById(id);
          const parent = canvas.parentNode;
          const newCanvas = document.createElement("canvas");
          newCanvas.id = id;
          parent.replaceChild(newCanvas, canvas);
        });

        log("Dashboard cleared");
        document.getElementById('duckdb-status').textContent = 'Tabla vac√≠a - carga datos primero';
        document.getElementById('duckdb-status').style.color = '#f7931a';
        document.getElementById('sql-btn').disabled = true;
        document.getElementById('sql-results').innerHTML = '';
      }
      
      // === DUCKDB WASM FUNCTIONS ===
      async function initDuckDB() {
        try {
          log('ü¶Ü Initializing DuckDB WASM...');
          const statusEl = document.getElementById('duckdb-status');
          
          // Wait for DuckDB module to load (it's async)
          let attempts = 0;
          while (!window.DuckDB && attempts < 50) {
            await new Promise(r => setTimeout(r, 100));
            attempts++;
          }
          
          if (!window.DuckDB) {
            throw new Error('DuckDB module failed to load after 5 seconds');
          }
          
          const JSDELIVR_BUNDLES = DuckDB.getJsDelivrBundles();
          const bundle = await DuckDB.selectBundle(JSDELIVR_BUNDLES);
          
          const worker_url = URL.createObjectURL(
            new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
          );
          
          const worker = new Worker(worker_url);
          const logger = new DuckDB.ConsoleLogger();
          duckDB = new DuckDB.AsyncDuckDB(logger, worker);
          
          await duckDB.instantiate(bundle.mainModule, bundle.pthreadWorker);
          duckConn = await duckDB.connect();
          duckDBReady = true;
          
          // Exponer para consola
          window.query = async (sql) => {
            const start = performance.now();
            const result = await duckConn.query(sql);
            const data = result.toArray().map(row => {
              const obj = {};
              for (const [k, v] of Object.entries(row)) {
                obj[k] = typeof v === 'bigint' ? Number(v) : v;
              }
              return obj;
            });
            console.log(`Query completed in ${Math.round(performance.now() - start)}ms`);
            console.table(data);
            return data;
          };
          window.duckDB = duckDB;
          window.duckConn = duckConn;
          
          statusEl.textContent = '‚úÖ DuckDB listo - carga datos para usar SQL';
          statusEl.style.color = '#1d9bf0';
          log('ü¶Ü DuckDB WASM ready! Use query("SQL") in console', 'success');
          
        } catch (err) {
          log(`ü¶Ü DuckDB init error: ${err.message}`, 'error');
          console.error('DuckDB init error:', err);
          document.getElementById('duckdb-status').textContent = '‚ùå Error initializing DuckDB';
          document.getElementById('duckdb-status').style.color = '#f44';
        }
      }
      
      async function runSQLQuery() {
        const sql = document.getElementById('sql-input').value.trim();
        if (!sql || !duckDBReady) return;
        
        const resultsEl = document.getElementById('sql-results');
        const btn = document.getElementById('sql-btn');
        btn.disabled = true;
        
        try {
          const start = performance.now();
          const result = await duckConn.query(sql);
          const data = result.toArray();
          const queryTime = Math.round(performance.now() - start);
          
          if (data.length === 0) {
            resultsEl.innerHTML = '<p style="color: #71767b;">No results</p>';
          } else {
            const columns = Object.keys(data[0]);
            let html = '<table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
            html += '<thead><tr>' + columns.map(c => `<th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #2f3336; color: #71767b;">${c}</th>`).join('') + '</tr></thead>';
            html += '<tbody>';
            data.slice(0, 100).forEach(row => {
              html += '<tr>' + columns.map(c => {
                let val = row[c];
                if (typeof val === 'bigint') val = Number(val);
                if (typeof val === 'number') val = val.toLocaleString();
                return `<td style="padding: 0.5rem; border-bottom: 1px solid #202e3a;">${val}</td>`;
              }).join('') + '</tr>';
            });
            html += '</tbody></table>';
            html += `<p style="margin-top: 0.5rem; font-size: 11px; color: #71767b;">${data.length} rows in ${queryTime}ms</p>`;
            resultsEl.innerHTML = html;
          }
          
          log(`ü¶Ü SQL: ${data.length} rows in ${queryTime}ms`, 'success');
        } catch (err) {
          resultsEl.innerHTML = `<p style="color: #f44;">Error: ${err.message}</p>`;
          log(`ü¶Ü SQL error: ${err.message}`, 'error');
        } finally {
          btn.disabled = false;
        }
      }

      // Iniciar - Wait for session_id
      initDuckDB();
      log("Dashboard ready. Enter Session ID and click Connect.");     // Don't auto-connect - wait for user to enter session_id\r\n      initDuckDB();\r\n      log(\"Dashboard ready. Enter Session ID from Connector and click Connect.\");", "StartLine": 971, "TargetContent": "      // Iniciar\r\n      connectWebSocket();\r\n      initDuckDB();\r\n      log(\"Dashboard ready. Connect to a tenant and load data.\");
    </script>
  </body>
</html>
